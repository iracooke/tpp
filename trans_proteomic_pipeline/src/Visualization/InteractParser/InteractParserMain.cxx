/*

Program       : Interact                                                    
Author        : Andrew Keller <akeller@systemsbiology.org>                                                       
Date          : 11.27.02 

Primary data object holding all mixture distributions for each precursor ion charge

Copyright (C) 2003 Andrew Keller

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

Andrew Keller
Institute for Systems Biology
401 Terry Avenue North 
Seattle, WA  98109  USA
akeller@systemsbiology.org

*/

#include "InteractParser.h"
#include "common/TPPVersion.h" // contains version number, name, revision
#include "Parsers/Parser/TagListComparator.h" // regression test stuff - bpratt Insilicos LLC, Nov 2005
#include "common/util.h"
#include <sys/stat.h>
#include <sys/types.h>

#include "Enzyme/ProteolyticEnzyme/ProteolyticEnzymeFactory/ProteolyticEnzymeFactory.h"

#ifdef WINDOWS_NATIVE
#include "common/wglob.h"		//glob for windows
#else
#include <glob.h>		//glob for real
#endif

int main(int argc, char** argv) {
  hooks_tpp handler(argc,argv); // set up install paths etc
  ProteolyticEnzymeFactory enz_fact;
  Array<char*>* inputfiles = new Array<char*>;
  char* next;

  char* database = NULL;
  char* exp_lbl = NULL;
  char* dbtype = NULL;
  char* datapath = NULL;
  char* enz = NULL;
  char* buf = NULL;
  int min_peplen = 7;
  int max_rank = 1;
  bool prot_name = false;
  bool update_chg = false;
  bool collision_eng = false;  
  bool comp_volt = false;
  bool prec_intens = false;
  bool fix_pyro_mods = false;
  bool get_rt = false;
  bool write_ref = true;
  bool error_peppro = true;
  
  if(argc < 3) {
    cerr <<  argv[0] << " (" << szTPPVersionInfo << ")" << endl;
    cerr << "usage: InteractParser <outfile> <file1"<<get_pepxml_dot_ext()<<"> <file2"<<get_pepxml_dot_ext()<<">... <options>" << endl;
    cerr << "options: " << endl;
    cerr << "\t-a<path_to_data_dir> :  path to the data " << endl;
    cerr << "\t-D<path_to_database> :  path to the database " << endl;
    cerr << "\t-T<database_type> :  database type" << endl;
    cerr << "\t-L<min_peptide_len (default 7)> :  minimum peptide length not rejected " << endl;
    cerr << "\t-R<max_rank (default 1)> :  maximum peptide rank in output" << endl;
    cerr << "\t-S :  record retention_time_sec in pepXML " << endl;
    cerr << "\t-I :  record precursor intensity in pepXML " << endl;
    cerr << "\t-G :  record collision energy in pepXML " << endl;
    cerr << "\t-V :  record compensation voltage in pepXML " << endl;
    cerr << "\t-P :  correct protein names (OMSSA)" << endl;
    cerr << "\t-C :  correct charge states (OMSSA)" << endl;
    cerr << "\t-M :  correct Pyro-Glu and Ammonia Loss Modifications E[111], Q[111] (OMSSA) " << endl;
    cerr << "\t-N :  don't write the input file reference to the output pepXML file (Use only when 1 input file is given) " << endl;
    cerr << "\t-W :  only warn don't skip files containing PeptideProphet results " << endl;
    cerr << "\t-E<enzyme>:  enzyme used in sample, one of : " << endl << endl;

    enz_fact.showEnzymesCatalog();
    

    cerr << endl;
    cerr << "The -P, -C and -M options are deprecated as it now applies these changes" << endl;
    cerr << "automatically if the input pepXML file was generated by OMSSA. It will also" << endl;
    cerr << "also correct some other common issues found in pepXML files written by " << endl;
    cerr << "various search engines." << endl;
    exit(1);
  }

  // regression test stuff - bpratt Insilicos LLC, Nov 2005
  int testarg = 0;
  eTagListFilePurpose testType=NO_TEST;
  char *testArgArg=NULL;
  char *testFileName=NULL;
  if (!strncmp(argv[1],REGRESSION_TEST_CMDLINE_ARG,strlen(REGRESSION_TEST_CMDLINE_ARG))) {
     checkRegressionTestArgs(testArgArg = strdup(argv[testarg=1]),testType);
     if (testType!=NO_TEST) {  
        testFileName = constructTagListFilename(argv[1+testarg], // input data file
           testArgArg, // args to the program
           "interactParser",  // program name
           testType); // user info output
    }
  }

  //Construct a file list, some of the files specified may be regular expression 
  //which need to be expanded first
//  FILE* fp;
  for(int k = 2+testarg; k < argc; k++) {
    next = new char[strlen(argv[k])+1000];  
    if (strchr(argv[k], '-')== argv[k]) {
      switch (argv[k][1]) {
      case 'D':
        database = new char[strlen(argv[k])];
	strcpy(database, &argv[k][2]);
	database[strlen(database)] = '\0';
	break;
      case 'X':
	exp_lbl= new char[strlen(argv[k])];
	strcpy(exp_lbl, &argv[k][2]);
	exp_lbl[strlen(exp_lbl)] = '\0';
	break;
      case 'a':
	datapath = new char[strlen(argv[k])];
	strcpy(datapath, &argv[k][2]);
	datapath[strlen(datapath)] = '\0';  
	break;
      case 'T':
	dbtype = new char[strlen(argv[k])];
	strcpy(dbtype, &argv[k][2]);
	dbtype[strlen(dbtype)] = '\0';  
	break;
      case 'E':
	enz = new char[strlen(argv[k])];
	strcpy(enz, &argv[k][2]);
	enz[strlen(enz)] = '\0';  
	break;
      case 'L':
	buf = new char[strlen(argv[k])];
	strcpy(buf, &argv[k][2]);
	buf[strlen(buf)] = '\0';
	min_peplen = atoi(buf);
	delete [] buf;
	break;
      case 'R':
	buf = new char[strlen(argv[k])];
	strcpy(buf, &argv[k][2]);
	buf[strlen(buf)] = '\0';
	max_rank = atoi(buf);
	delete [] buf;
	break;
      case 'S':
	get_rt = true;
	break;
      case 'W':
	error_peppro = false;
	break;
      case 'P':
	prot_name = true;
	break;
      case 'C':
	update_chg = true;
	break;
      case 'G':
	collision_eng = true;
	break;
      case 'I':
	prec_intens = true;
	break;
      case 'N':
	write_ref = false;
	break;
      case 'V':
	comp_volt = true;
	break;
      case 'M':
	fix_pyro_mods = true;
	break;
      }
    }
    else if (strchr(argv[k], '*')!=NULL || strchr(argv[k], '?')!=NULL || 
	strchr(argv[k], '[')!=NULL || strchr(argv[k], '{')!=NULL) {
      glob_t g;
      struct stat s;
      glob(argv[k], 0, NULL, &g);

      for (int i = 0; i < g.gl_pathc; i++) {
	stat((g.gl_pathv)[i], &s);
	if (s.st_size <= 0) {
	  cout << "WARNING: InteractParser found and skipped empty file: " <<  (g.gl_pathv)[i] << endl;
	}
	else {
	  inputfiles->insertAtEnd((g.gl_pathv)[i]);

	}
      }

    }
    else {
      strcpy(next, argv[k]);
      inputfiles->insertAtEnd(next);
    }
  } // next file

  char *outfilename = argv[1+testarg];
  InteractParser *p = new InteractParser(inputfiles, outfilename, database, datapath, dbtype, enz, prot_name, update_chg, exp_lbl, min_peplen, max_rank, collision_eng, fix_pyro_mods, comp_volt, prec_intens, get_rt, write_ref, error_peppro);

  if (testType!=NO_TEST) {
     TagListComparator("interactParser",testType,outfilename,testFileName);
	 free(testArgArg);
     delete[] testFileName;
  }

  delete p;
  return 0;
}
